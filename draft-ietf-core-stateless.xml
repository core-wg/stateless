<?xml version="1.0" encoding="us-ascii"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC2119 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.2119.xml">
  <!ENTITY RFC3610 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.3610.xml">
  <!ENTITY RFC4107 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.4107.xml">
  <!ENTITY RFC6234 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.6234.xml">
  <!ENTITY RFC7228 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.7228.xml">
  <!ENTITY RFC7252 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.7252.xml">
  <!ENTITY RFC7641 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.7641.xml">
  <!ENTITY RFC7959 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.7959.xml">
  <!ENTITY RFC8174 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.8174.xml">
  <!ENTITY RFC8323 SYSTEM "http://www.rfc-editor.org/refs/bibxml/reference.RFC.8323.xml">
  <!ENTITY I-D.ietf-6tisch-minimal-security SYSTEM "http://www.rfc-editor.org/refs/bibxml3/reference.I-D.ietf-6tisch-minimal-security.xml">
  <!ENTITY I-D.ietf-core-echo-request-tag SYSTEM "http://www.rfc-editor.org/refs/bibxml3/reference.I-D.ietf-core-echo-request-tag.xml">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<?rfc compact="yes"?>
<?rfc sortrefs="yes"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="3"?>

<rfc category="std" docName="draft-ietf-core-stateless-latest" ipr="trust200902" updates="7252, 8323">

  <front>

    <title abbrev="Stateless Client State for CoAP">
      Extended&#160;Tokens&#160;and&#160;Stateless&#160;Clients
      in&#160;the&#160;Constrained&#160;Application&#160;Protocol&#160;(CoAP)
    </title>

    <author initials="K." surname="Hartke" fullname="Klaus Hartke">
      <organization>Ericsson</organization>
      <address>
        <postal>
          <street>Torshamnsgatan 23</street>
          <city>Stockholm</city>
          <code>SE-16483</code>
          <country>Sweden</country>
        </postal>
        <email>klaus.hartke@ericsson.com</email>
      </address>
    </author>

    <date/>

    <workgroup>CoRE Working Group</workgroup>

    <abstract>

      <t>
        This document provides considerations for alleviating CoAP clients and
        intermediaries of keeping per-request state. To facilitate this, this
        document additionally introduces a new, optional CoAP protocol extension
        for extended token lengths.
      </t>

      <t>
        This document updates RFCs 7252 and 8323 with a new definition of the
        TKL field in the CoAP message header.
      </t>

    </abstract>

  </front>

  <middle>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Introduction" anchor="introduction">

      <t>
        The Constrained Application Protocol (CoAP) <xref target="RFC7252"/> is
        a RESTful application-layer protocol for <xref
        target="RFC7228">constrained environments</xref>. In CoAP, clients (or
        intermediaries in the client role) make requests to servers (or
        intermediaries in the server role), which satisfy the requests by
        returning responses.
      </t>

      <t>
        While a request is ongoing, a client typically needs to keep some state that
        it requires for processing the response when that arrives. Identification
        of this state is done in CoAP by means of a token, an
        opaque sequence of bytes chosen by the client and included in the CoAP
        request, and that is returned by the server verbatim in any resulting CoAP
        response (<xref target="stateful-exchange"/>).
      </t>

<figure anchor="stateful-exchange" title="Token as an Identifier for Request State"><artwork align="center"><![CDATA[
+-----------------+     request with     +------------+
|        |        |   state identifier   |            |
|        |        |       as token       |            |
|    .-<-+->------|--------------------->|------.     |
|   _|_           |                      |      |     |
|  /   \ stored   |                      |      |     |
|  \___/ state    |                      |      |     |
|    |            |                      |      |     |
|    '->-+-<------|<---------------------|------'     |
|        |        |     response with    |            |
|        v        |   token echoed back  |            |
+-----------------+                      +------------+
      Client                                 Server
]]></artwork></figure>

      <t>
        In some scenarios, it can be beneficial to reduce the amount of state
        that is stored at the client at the cost of increased message sizes. A client can
        opt into this by serializing (parts of) its state into the token itself and then
        recovering this state from the token in the response (<xref
        target="stateless-exchange"/>).
      </t>

<figure anchor="stateless-exchange" title="Token as Serialization of Request State"><artwork align="center"><![CDATA[
+-----------------+     request with     +------------+
|        |        |   serialized state   |            |
|        |        |       as token       |            |
|        +--------|=====================>|------.     |
|                 |                      |      |     |
|    look ma,     |                      |      |     |
|    no state!    |                      |      |     |
|                 |                      |      |     |
|        +--------|<=====================|------'     |
|        |        |     response with    |            |
|        v        |   token echoed back  |            |
+-----------------+                      +------------+
      Client                                 Server
]]></artwork></figure>

      <t>
        <xref target="stateless-clients"/> of this document provides
        considerations for clients becoming "stateless" in this way.
        (The term "stateless" is in quotes here, because it's a bit
        oversimplified. Such clients still need to maintain per-server state and other
        kinds of state. So it would be more accurate to
        just say that the clients are avoiding per-request state.)
      </t>

      <t>
        <xref target="stateless-intermediaries"/> of this document
        extends the considerations for clients to intermediaries, which
        may not only want to avoid keeping state for the requests they
        send to servers but also for the requests they receive from
        clients.
      </t>

      <t>
        The serialization of state into tokens is limited by the fact
        that both <xref target="RFC7252">CoAP over UDP</xref> and <xref
        target="RFC8323">CoAP over reliable transports</xref> restrict
        the maximum token length to 8 bytes. To overcome this
        limitation, <xref target="extended-tokens"/> of this document
        first introduces a CoAP protocol extension for extended token
        lengths.
      </t>

      <t>
         While the use case (avoiding per-request state) and the mechanism
         (extended token lengths) presented in this document are closely
         related, both can be used independently of each other: Some
         implementations may be able to fit their state in just 8 bytes; some
         implementations may have other use cases for extended token lengths.
      </t>

      <section title="Terminology">

        <t>
          In this document, the term "stateless" refers to an implementation
          strategy for a client (or intermediary in the client role) that does
          not require it to keep state for the individual requests it sends to a
          server (or intermediary in the server role). The client still needs to
          keep state for each server it communicates with (e.g., for token
          generation, message retransmission, and congestion control).
        </t>

        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
          "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
          "OPTIONAL" in this document are to be interpreted as described in
          <xref target="RFC2119">BCP 14</xref> <xref target="RFC8174"/> when,
          and only when, they appear in all capitals, as shown here.
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Extended Tokens" anchor="extended-tokens">

      <t>
        This document updates the message formats defined for <xref
        target="RFC7252">CoAP over UDP</xref> and <xref target="RFC8323">CoAP
        over TCP, TLS, and WebSockets</xref> with a new definition of the TKL
        field.
      </t>

      <section title="Extended Token Length (TKL) Field" anchor="tkl-field">

        <t>
          The definition of the TKL field is updated as follows:
          <list style="hanging">
            <t hangText="Token Length (TKL):">
              4-bit unsigned integer. A value between 0 and 12 inclusive
              indicates the length of the variable-length Token field in bytes.
              The other three values are reserved for special constructs:
              <list style="hanging">
                <t hangText="13:">
                  An 8-bit unsigned integer directly precedes the Token field and
                  indicates the length of the Token field minus 13.
                </t>
                <t hangText="14:">
                  A 16-bit unsigned integer in network byte order directly precedes the
                  Token field and indicates the length of the Token field minus
                  269.
                </t>
                <t hangText="15:">
                  Reserved. This value MUST NOT be sent and MUST be processed as
                  a message format error.
                </t>
              </list>
            </t>
          </list>
        </t>

        <t>
          All other fields retain their definitions.
        </t>

        <t>
          The updated message formats are illustrated in <xref
          target="message-formats"/>.
        </t>

        <t>
          The new definition of the TKL field increases the maximum token length that can be represented in a
          message to 65804 bytes. However, the maximum token length that sender and
          recipient implementations support may be shorter. For example, a
          constrained node of <xref target="RFC7228">Class 1</xref> might
          support extended token lengths only up to 32 bytes.
        </t>

        <t>
          In CoAP over UDP, it is often beneficial to keep CoAP messages small
          enough to avoid IP fragmentation. The maximum practical token length
          may therefore also be influenced by the Path MTU. See Section 4.6 of
          RFC 7252 for details.
        </t>

      </section>

      <section title="Discovering Support" anchor="discovery">

        <t>
          Extended token lengths require support from server implementations.
          Support can be discovered by a client implementation in one of two
          ways:
          <list style="symbols">
            <t>
              Where Capabilities and Settings Messages (CSMs) are available,
              such as in CoAP over TCP, support can be discovered using the
              Extended-Token-Length Capability Option defined in <xref
              target="capability-option"/>.
            </t>
            <t>
              Otherwise, such as in CoAP over UDP, support can only be
              discovered by trial-and-error, as described in <xref
              target="trial-and-error"/>.
            </t>
          </list>
        </t>

        <section title="Extended-Token-Length Capability Option" anchor="capability-option">

          <t>
            A server can use the elective Extended-Token-Length Capability
            Option to indicate the maximum token length it can accept in
            requests.
          </t>

          <texttable title="The Extended-Token-Length Capability Option" anchor="capability-option-definition">
            <ttcol align="right">#</ttcol>
            <ttcol align="left">C</ttcol>
            <ttcol align="left">R</ttcol>
            <ttcol align="left">Applies to</ttcol>
            <ttcol align="left">Name</ttcol>
            <ttcol align="left">Format</ttcol>
            <ttcol align="left">Length</ttcol>
            <ttcol align="left">Base Value</ttcol>

            <c>TBD</c>
            <c></c>
            <c></c>
            <c>CSM</c>
            <c>Extended-Token-Length</c>
            <c>uint</c>
            <c>0-3</c>
            <c>8</c>

            <postamble>C=Critical, R=Repeatable</postamble>
          </texttable>

          <t>
            As per Section 3 of RFC 7252, the base value (and the value used
            when this option is not implemented) is 8.
          </t>

          <t>
            The active value of the Extended-Token-Length Option is replaced
            each time the option is sent with a modified value. Its starting
            value is its base value.
          </t>

          <t>
            The option value MUST NOT be less than 8 or greater than 65804. If
            an option value less than 8 is received, the option MUST be ignored.
            If an option value greater than 65804 is received, the option value
            MUST be set to 65804.
          </t>

          <t>
            Any option value greater than 8 implies support for the new
            definition of the TKL field specified in <xref target="tkl-field"/>.
            Indication of support by a server does not oblige a client to
            actually make use of token lengths greater than 8.
          </t>

          <t>
            If a server receives a request with a token of a length greater than what
            it indicated in its Extended-Token-Length Option, it MUST handle the
            request as a message format error.
          </t>

          <t>
            If a server receives a request with a token of a length less than or
            equal to what it indicated in its Extended-Token-Length Option but
            is unwilling or unable to handle the token at that time, it MUST NOT
            handle the request as a message format error. Instead, it SHOULD
            return a 5.03 (Service Unavailable) response.
          </t>

          <t>
            The Extended-Token-Length Capability Option does not apply to
            responses. The sender of a request is simply expected not to use a
            token of a length greater than it is willing to accept in a
            response.
          </t>

        </section>

        <section title="Trial-and-Error" anchor="trial-and-error">

          <t>
            A server implementation that does not support the updated definition of the TKL
            field specified in <xref target="tkl-field"/> will consider a
            request with a TKL field value outside the range 0 to 8 a message
            format error and reject it (Section 3 of RFC 7252). A client can
            therefore determine support by sending a request with an extended
            token length and checking whether it is rejected by the server or
            not.
          </t>

          <t>
            In CoAP over UDP, the way a request message is rejected depends on the message type.
            A Confirmable message with a message format error
            is rejected with a Reset message (Section 4.2 of RFC 7252). A
            Non-confirmable message with a message format error is either rejected
            with a Reset message or just silently ignored (Section 4.3 of RFC
            7252). To reliably get a Reset message, it is therefore REQUIRED that clients use a Confirmable
            message for determining support.
          </t>

          <t>
            As per RFC 7252, Reset messages are empty and do not contain a
            token; they only return the Message ID (<xref
            target="trial-and-error-illustration"/>). They also do not contain
            any indication of what caused a message format error. To avoid any
            ambiguity, it is therefore RECOMMENDED that clients use a request
            that has no potential message format error other than the extended
            token length.
          </t>

<figure anchor="trial-and-error-illustration" title="A Confirmable Request With an Extended Token is Rejected With a Reset Message if the Server Does Not Have Support"><artwork align="center"><![CDATA[
+-----------------+   request message    +------------+
|        |        |    with extended     |            |
|        |        |     token length     |            |
|    .-<-+->------|--------------------->|------.     |
|   _|_           |                      |      |     |
|  /   \ stored   |                      |      |     |
|  \___/ state    |                      |      |     |
|    |            |                      |      |     |
|    '->-+-<------|<---------------------|------'     |
|        |        |     reset message    |            |
|        v        |   with only message  |            |
+-----------------+    ID echoed back    +------------+
      Client                                 Server
]]></artwork></figure>

          <t>
            An example of a suitable request is a GET request in a Confirmable  message that
            includes only an If-None-Match option and a token of the greatest length
            that the client intends to use. Any response with the same token
            echoed back indicates that tokens up to that length are supported by
            the server.
          </t>

          <t>
            Since network addresses may change,
            a client SHOULD NOT assume that extended token lengths are supported
            by a server later than 60 minutes after receiving the most-recent response with an extended
            token length.
          </t>

          <t>
            If a server supports extended token lengths but receives a request
            with a token of a length it is unwilling or unable to handle, it
            MUST NOT reject the message, as that would imply that extended token
            lengths are not supported at all. Instead, if the server cannot
            handle the request at the time, it SHOULD return a 5.03 (Service
            Unavailable) response; if the server will never be able to handle the request
            (e.g., because the token is too large), it SHOULD return a 4.00 (Bad
            Request) response.
          </t>

          <t>
            <list style="hanging">
              <t hangText="Design Note:">
                The requirement to return an error response when a
                token cannot be handled might seem somewhat contradictory, as
                returning the error response requires the server also to return the
                token it cannot handle. However,
                processing a request usually involves a number of steps from
                receiving the message to passing it to application logic.
                The idea is that a server implementing this extension
                supports large tokens at least in its first few processing steps, enough to
                return an error response rather than a Reset message.
              </t>
            </list>
          </t>

          <t>
            <list style="hanging">
              <t hangText="Design Note:">
                To make the trial-and-error-based discovery not too complicated, no effort is made to indicate the maximum supported
                token length. A client implementation would probably
                already choose the shortest token possible for the task (like
                being stateless as described in <xref
                target="stateless-clients"/>), so it would probably not be able
                to reduce the length any further anyway should a server
                indicate a lower limit.
              </t>
            </list>
          </t>

        </section>

      </section>

      <section title="Intermediaries" anchor="hop-by-hop">

        <t>
          Tokens are a hop-by-hop feature: If there are one or more
          intermediaries between a client and a server, every token is scoped to
          the exchange between a node in the client role and the node in the
          server role that it is immediately interacting with.
        </t>

        <t>
          When an intermediary receives a request, the only requirement is that
          it echoes the token back in any resulting response. There is no
          requirement or expectation that an intermediary passes a client's
          token on to a server or that an intermediary uses extended token
          lengths itself in its request to satisfy a request with an extended
          token length. Discovery needs to be performed for each hop where extended token lengths are to be used.
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Stateless Clients" anchor="stateless-clients">

      <t>
        A client can be alleviated of keeping per-request state as follows:
        <list style="numbers">
          <t>
            The client serializes (parts of) its per-request state into
            a sequence of bytes and sends those bytes as the token of
            its request to the server.
          </t>
          <t>
            The server returns the token verbatim in the response to the
            client, which allows the client to recover the state and
            process the response as if it had kept the state locally.
          </t>
        </list>
      </t>

      <t>
        As servers are just expected to return any token verbatim to the
        client, this implementation strategy for clients does not impact the
        interoperability of client and server implementations. However,
        there are a number of significant, non-obvious implications
        (e.g., related to security and other CoAP protocol features)
        that client implementations need take into consideration.
      </t>

      <t>
        The following subsections discuss some of these considerations.
      </t>

      <section title="Serializing Client State" anchor="serialized-state">

        <t>
          The format of the serialized state is generally an
          implementation detail of the client and opaque to the server.

          However, serialized state information is an attractive target
          for both unwanted nodes (e.g., on-path attackers) and wanted
          nodes (e.g., any configured forward proxy) on the path.

          The serialization format therefore needs to include security
          measures such as the following:
          <list style="symbols">
            <t>
              A client SHOULD protect the integrity of the state information
              serialized in a token.
            </t>
            <t>
              Even when the integrity of the serialized state is protected, an
              attacker may still replay a response, making the client
              believe it sent the same request twice.

              For this reason, the client SHOULD implement replay
              protection (e.g., by using sequence numbers and a replay
              window).

              For replay protection, integrity protection is REQUIRED.
            </t>
            <t>
              If processing a response without keeping request state is
              sensitive to the time elapsed since sending the request, then the
              client SHOULD include freshness information (e.g., a timestamp) in
              the serialized state and reject any response where the freshness
              information is insufficiently fresh.
            </t>
            <t>
              Information in the serialized state may be privacy
              sensitive.

              A client SHOULD encrypt the serialized state if it
              contains privacy sensitive information that an attacker
              would not get otherwise.
            </t>
            <t>
              When a client changes the format of the serialized state,
              it SHOULD prevent false interoperability with the previous
              format (e.g., by changing the key used for integrity
              protection or changing a field in the serialized state).
            </t>
          </list>
        </t>

      </section>

      <section title="Using Extended Tokens">

        <t>
          A client that depends on
          support for extended token lengths (<xref target="extended-tokens"/>)
          from the server to avoid keeping request state needs to perform a
          discovery of support (<xref target="discovery"/>) before it can be
          stateless.
        </t>

        <t>
          This discovery MUST be performed in a stateful way, i.e.,
          keeping state for the request (<xref target="stateful-discovery"/>):
          If the client was stateless from the start and the server does not
          support extended tokens, then any error message could not be processed
          since the state would neither be present at the client nor returned in
          the Reset message (<xref target="stateless-discovery"/>).
        </t>

<figure anchor="stateful-discovery" title="Depending on Extended Tokens for Being Stateless First Requires a Successful Stateful Discovery of Support"><artwork align="center"><![CDATA[
+-----------------+    dummy request     +------------+
|        |        |    with extended     |            |
|        |        |        token         |            |
|    .-<-+->------|=====================>|------.     |
|   _|_           |                      |      |     |
|  /   \ stored   |                      |      |     |
|  \___/ state    |                      |      |     |
|    |            |                      |      |     |
|    '->-+-<------|<=====================|------'     |
|        |        |     response with    |            |
|        |        |    extended token    |            |
|        |        |      echoed back     |            |
|        |        |                      |            |
|        |        |                      |            |
|        |        |     request with     |            |
|        |        |   serialized state   |            |
|        |        |       as token       |            |
|        +--------|=====================>|------.     |
|                 |                      |      |     |
|    look ma,     |                      |      |     |
|    no state!    |                      |      |     |
|                 |                      |      |     |
|        +--------|<=====================|------'     |
|        |        |     response with    |            |
|        v        |   token echoed back  |            |
+-----------------+                      +------------+
      Client                                 Server
]]></artwork></figure>

<figure anchor="stateless-discovery" title="Stateless Discovery of Support Does Not Work"><artwork align="center"><![CDATA[
+-----------------+    dummy request     +------------+
|        |        |    with extended     |            |
|        |        |        token         |            |
|        +--------|=====================>|------.     |
|                 |                      |      |     |
|                 |                      |      |     |
|                 |                      |      |     |
|                 |                      |      |     |
|              ???|<---------------------|------'     |
|                 |     reset message    |            |
|                 |   with only message  |            |
+-----------------+    ID echoed back    +------------+
      Client                                 Server
]]></artwork></figure>

        <t>
          In environments where support can be reliably discovered through some
          other means, the discovery of support is OPTIONAL. An example for this
          is the <xref target="I-D.ietf-6tisch-minimal-security">Constrained
          Join Protocol (CoJP) in a 6TiSCH network</xref>, where support for
          extended tokens is required from all relevant parties.
        </t>

      </section>

      <section title="Transmitting Messages">

        <t>
          In <xref target="RFC7252">CoAP over UDP</xref>, a client has the choice between
          Confirmable and Non-confirmable messages for requests. When using
          Non-confirmable messages, a client does not have to keep any message
          exchange state, which can help in the goal of avoiding state. When using
          Confirmable messages, a client needs to keep message exchange
          state for performing retransmissions and handling Acknowledgement and
          Reset messages, however. Non-confirmable messages are therefore better suited for avoiding state.
          In any case, a client still needs to keep congestion control state, i.e.,
          maintain state for each node it communicates with and enforce limits
          like NSTART.
        </t>

        <t>
          As per Section 5.2 of RFC 7252, a client must be prepared to receive a response as a
          piggybacked response, a separate response, or Non-confirmable response,
          regardless of the message type used for the
          request. A stateless client MUST handle these response types as
          follows:
          <list style="symbols">
            <t>
              If a piggybacked response passes the checks for token integrity
              and freshness (<xref target="serialized-state"/>), the client processes the message as
              specified in RFC 7252; otherwise, it processes the acknowledgement
              portion of the message as specified in RFC 7252 and silently
              discards the response portion.
            </t>
            <t>
              If a separate response passes the checks for token integrity and
              freshness, the client processes the message as specified in
              RFC 7252; otherwise, it rejects the message as specified in
              Section 4.2 of RFC 7252.
            </t>
            <t>
              If a Non-confirmable response passes the checks for token
              integrity and freshness, the client processes the message
              as specified in RFC 7252; otherwise, it rejects the message as
              specified in Section 4.3 of RFC 7252.
            </t>
          </list>
        </t>

      </section>

    </section>

    <section title="Stateless Intermediaries" anchor="stateless-intermediaries">

      <t>
        Tokens are a hop-by-hop feature: If a client makes a request to an
        intermediary, that intermediary needs to store the client's token
        (along with the client's transport address) while it makes its own
        request towards the origin server and waits for the
        response. When the intermediary receives the response, it looks up
        the client's token and transport address for the received request and
        sends an appropriate response to the client.
      </t>

      <t>
        An intermediary might want to be "stateless" not only in its role as
        a client but also in its role as a server, i.e., be
        alleviated of storing the client information for
        the requests it receives.
      </t>

      <t>
        Such an intermediary can be implemented by serializing the
        client information along with the request state into the token towards the origin server.
        When the intermediary receives the response, it can recover
        the client information from the token and use it to satisfy the client's
        request and therefore doesn't need to store it itself.
      </t>

      <t>
        The following subsections discuss some considerations for this approach.
      </t>

      <section title="Observing Resources">

        <t>
          One drawback of the approach is that an intermediary, without keeping
          request state, is unable to aggregate multiple requests for the same
          target resource, which can significantly reduce efficiency. In
          particular, when clients <xref target="RFC7641">observe</xref> the
          same resource, aggregating requests is REQUIRED (Section 3.1 of RFC
          7641). This requirement cannot be satisfied without keeping request
          state.
        </t>

        <t>
          Furthermore, an intermediary that does not keep track of the clients
          observing a resource is not able to determine whether these
          clients are still interested in receiving further notifications
          (Section 3.5 of RFC 7641) or want to cancel an observation (Section 3.6 of
          RFC 7641).
        </t>

        <t>
          Therefore, an intermediary MUST NOT include an Observe Option in
          requests it sends without keeping both the request state for the requests it sends and the
          client information for the requests it receives.
        </t>

      </section>

      <section title="Block-Wise Transfers">

        <t>
          When using <xref target="RFC7959">block-wise transfers</xref>, a
          server might not be able to distinguish blocks originating from
          different clients once they have been forwarded by an intermediary.
          Intermediaries need to ensure that this does not lead to inconsistent
          resource state by keeping distinct block-wise request operations on
          the same resource apart, e.g., utilizing the <xref
          target="I-D.ietf-core-echo-request-tag">Request-Tag Option</xref>.
        </t>

      </section>

      <section title="Gateway Timeouts">

        <t>
          As per Section 5.7.1 of RFC 7252, an intermediary is REQUIRED to
          return a 5.04 (Gateway Timeout) response if it cannot obtain a
          response within a timeout. However, if an intermediary does not keep
          the client information for the requests it receives, it cannot return
          such a response. Therefore, in this case, the gateway cannot return
          such a response and as such cannot implement such a timeout.
        </t>

      </section>

      <section title="Extended Tokens">

        <t>
          A client may make use of extended token lengths in a request to an
          intermediary that wants to be "stateless". This means that such an intermediary
          may have to serialize potentially very large client information into
          its token towards the origin server. The tokens can grow even further
          when it progresses along a chain of intermediaries that all want to be
          "stateless".
        </t>

        <t>
          Intermediaries SHOULD limit the size of client information they're
          serializing into their own tokens. An intermediary can do this, for
          example, by limiting the extended token lengths it accepts from its
          clients (see <xref target="discovery"/>) or by keeping the client
          information locally when the client information exceeds the limit
          (i.e., not being "stateless").
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Security Considerations" anchor="security">

      <section title="Extended Tokens">

        <t>
          Tokens significantly larger than the 8 bytes specified in RFC 7252
          have implications in particular for nodes with constrained memory size
          that need to be mitigated. A node in the server role supporting
          extended token lengths may be vulnerable to a denial-of-service when
          an attacker (either on-path or a malicious client) sends large tokens
          to fill up the memory of the node. Implementations need to be prepared
          to handle such messages.
        </t>

      </section>

      <section title="Stateless Clients and Intermediaries">

        <t>
          Transporting the state needed by a client to process a response as
          serialized state information in the token has several significant and
          non-obvious security and privacy implications that need to be
          mitigated; see <xref target="serialized-state"/> for recommendations.

          In addition to the format requirements outlined there, implementations
          need to ensure that they are not vulnerable to maliciously crafted,
          delayed, or replayed tokens.
        </t>

        <t>
          It is generally expected that the use of encryption, integrity
          protection, and replay protection for serialized state is appropriate.

          In the absence of integrity and reply protection, an on-path attacker
          or rogue server/intermediary could return a state (either one modified
          in a reply, or an unsolicited one) that could alter the internal state
          of the client.

          However, a careful analysis of any potential attacks to the security
          and privacy properties of the system might reveal that there are cases
          where such cryptographic protections do not add value in a specific
          case.
        </t>

        <t>
          <xref target="RFC3610">AES-CCM</xref> with a 64-bit tag is
          RECOMMENDED, combined with a sequence number and a replay window.

          Where encryption is not needed, <xref
          target="RFC6234">HMAC-SHA-256</xref>, combined with a sequence number
          and a replay window, may be used.
        </t>

        <t>
          When using an encryption mode that depends on a nonce, such as AES-CCM, repeated use of the same nonce under the same key
          causes the cipher to fail catastrophically. If a nonce is ever used
          for more than one encryption operation with the same key, then the
          same key stream gets used to encrypt both plaintexts and the
          confidentiality guarantees are voided. Devices with low-quality entropy
          sources -- as is typical with constrained devices, which incidentally
          happen to be a natural candidate for the stateless mechanism described
          in this document -- need to carefully pick a nonce generation
          mechanism that provides the above uniqueness guarantee. Additionally,
          since it can be difficult to use AES-CCM securely when using
          statically configured keys, implementations should use <xref
          target="RFC4107">automated key management</xref>.
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="IANA Considerations">

      <section title="CoAP Signaling Option Number">

        <t>
          The following entries are added to the "CoAP Signaling Option Numbers"
          registry within the "CoRE Parameters" registry.
        </t>

        <texttable>
          <ttcol align="left">Applies to</ttcol>
          <ttcol align="right">Number</ttcol>
          <ttcol align="left">Name</ttcol>
          <ttcol align="left">Reference</ttcol>

          <c>7.01</c>
          <c>TBD</c>
          <c>Extended-Token-Length</c>
          <c>[[this document]]</c>
        </texttable>

        <t>
          [[NOTE TO RFC EDITOR: Please replace "TBD" in this section and in
          <xref target="capability-option-definition"/> with the code point
          assigned by IANA.]]
        </t>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </middle>

  <back>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <references title="Normative References">

      &RFC2119;
      &RFC7252;
      &RFC7641;
      &RFC7959;
      &RFC8174;
      &RFC8323;

    </references>

    <references title="Informative References">

      &RFC3610;
      &RFC4107;
      &RFC6234;
      &RFC7228;

      &I-D.ietf-core-echo-request-tag;

      &I-D.ietf-6tisch-minimal-security;

    </references>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Updated Message Formats" anchor="message-formats">

      <t>
        In <xref target="extended-tokens"/>, this document updates the
        CoAP message formats by specifying a new definition of the TKL
        field in the message header. As an alternative presentation of
        this update, this appendix shows the CoAP message formats for
        <xref target="RFC7252">CoAP over UDP</xref> and <xref
        target="RFC8323">CoAP over TCP, TLS, and WebSockets</xref> with
        the new definition applied.
      </t>

      <section title="CoAP over UDP">

<figure><artwork align="center"><![CDATA[
                0   1   2   3   4   5   6   7
              +-------+-------+---------------+
              |       |       |               |
              |  Ver  |   T   |      TKL      |   1 byte
              |       |       |               |
              +-------+-------+---------------+
              |                               |
              |             Code              |   1 byte
              |                               |
              +-------------------------------+
              |                               |
              |                               |
              |                               |
              +-         Message ID          -+   2 bytes
              |                               |
              |                               |
              |                               |
              +-------------------------------+
              \                               \
              /              TKL              /   0-2 bytes
              \          (extended)           \
              +-------------------------------+
              \                               \
              /             Token             /   0-65804 bytes
              \                               \
              +-------------------------------+
              \                               \
              /                               /
              \                               \
              /            Options            /   0 or more bytes
              \                               \
              /                               /
              \                               \
              +---------------+---------------+
              |               |               |
              |      15       |       15      |   1 byte (if payload)
              |               |               |
              +---------------+---------------+
              \                               \
              /                               /
              \                               \
              /            Payload            /   0 or more bytes
              \                               \
              /                               /
              \                               \
              +-------------------------------+
]]></artwork></figure>

      </section>

      <section title="CoAP over TCP/TLS">

<figure><artwork align="center"><![CDATA[
                0   1   2   3   4   5   6   7
              +---------------+---------------+
              |               |               |
              |      Len      |      TKL      |   1 byte
              |               |               |
              +---------------+---------------+
              \                               \
              /              Len              /   0-4 bytes
              \          (extended)           \
              +-------------------------------+
              |                               |
              |             Code              |   1 byte
              |                               |
              +-------------------------------+
              \                               \
              /              TKL              /   0-2 bytes
              \          (extended)           \
              +-------------------------------+
              \                               \
              /             Token             /   0-65804 bytes
              \                               \
              +-------------------------------+
              \                               \
              /                               /
              \                               \
              /            Options            /   0 or more bytes
              \                               \
              /                               /
              \                               \
              +---------------+---------------+
              |               |               |
              |      15       |       15      |   1 byte (if payload)
              |               |               |
              +---------------+---------------+
              \                               \
              /                               /
              \                               \
              /            Payload            /   0 or more bytes
              \                               \
              /                               /
              \                               \
              +-------------------------------+
]]></artwork></figure>

      </section>

      <section title="CoAP over WebSockets">

<figure><artwork align="center"><![CDATA[
                0   1   2   3   4   5   6   7
              +---------------+---------------+
              |               |               |
              |       0       |      TKL      |   1 byte
              |               |               |
              +---------------+---------------+
              |                               |
              |             Code              |   1 byte
              |                               |
              +-------------------------------+
              \                               \
              /              TKL              /   0-2 bytes
              \          (extended)           \
              +-------------------------------+
              \                               \
              /             Token             /   0-65804 bytes
              \                               \
              +-------------------------------+
              \                               \
              /                               /
              \                               \
              /            Options            /   0 or more bytes
              \                               \
              /                               /
              \                               \
              +---------------+---------------+
              |               |               |
              |      15       |       15      |   1 byte (if payload)
              |               |               |
              +---------------+---------------+
              \                               \
              /                               /
              \                               \
              /            Payload            /   0 or more bytes
              \                               \
              /                               /
              \                               \
              +-------------------------------+
]]></artwork></figure>

      </section>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

    <section title="Acknowledgements" numbered="no">

      <t>
        This document is based on the requirements of and work on the <xref
        target="I-D.ietf-6tisch-minimal-security">Minimal Security Framework for
        6TiSCH</xref> by Malisa Vucinic, Jonathan Simon, Kris Pister, and
        Michael Richardson.
      </t>

      <!-- sorted by last name -->
      <t>
        Thanks to
        Christian Amsuss,
        Carsten Bormann,
        Roman Danyliw,
        Christer Holmberg,
        Benjamin Kaduk,
        Ari Keranen,
        Erik Kline,
        Murray Kucherawy,
        Warren Kumari,
        Barry Leiba,
        David Mandelberg,
        Dan Romascanu,
        Jim Schaad,
        Goran Selander,
        Malisa Vucinic,
        Eric Vyncke, and
        Robert Wilton
        for helpful comments and discussions that have shaped the document.
      </t>

      <t>
        Special thanks to John Mattsson for his contributions to the security
        considerations of the document, and to Thomas Fossati for his in-depth
        review, copious comments, and suggested text.
      </t>

    </section>

    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->
    <!-- **************************************************************** -->

  </back>

</rfc>
